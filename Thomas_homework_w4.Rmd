---
title: "RBasics"
output: 
    html_document:
        theme: default
        highlight: pygments

---

# Writing a basic function:


```{r}
#what we saw in class
compute_area <- function(r_in){
  area <- pi * r_in ^ 2
  return(area)
}

compute_area(3)
```




```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

R 語言與資料科學導論作業 (W4)
=============================

語言所 博三 D04142001 司馬智 Thomas Van Hoey


## A. Complete compute_area(...) (70%)

### 撰寫compute_area函數
請完成課堂上的compute_area(...)，它必須能夠：

* 計算二種形狀的面積和周長：
    * 圓形（以 半徑radius 長length 當 參數parameter）
    * 正方形（以 邊長side length 當 參數parameter）

函數function 的 型態(signature)：

* 輸入為兩個參數parameter：
    * x: 邊長side length 或半徑radius
    * shape_str: "circle" 或是 "square"
* 函數回傳：
    * 一個vector。該vector有兩個元素。第一個是面積，第二個是周長。請記得給它恰當的名稱。

This is my function.

```{r func_def, echo=TRUE}
compute_area <- function(r_in,shape_str){
  if(shape_str == "circle"){
    area <- pi * r_in ^ 2
    circumference <- 2 * pi * r_in
    return(c(area, circumference))
  } else if (shape_str == "square") {
    area <- r_in ^ 2
    circumference <- 4 * r_in
    return(c(area, circumference))
  } else {
    return("You need to set the shape_str argument to 'circle' or 'square'!")
  }
}
```

This is what the function looks like for a circle (shape_str = "circle").
```{r}
compute_area(3, "circle")
```

This is what the function looks like for a square (shape_str = "square").
```{r}
compute_area(3, "square")
```

This is what the function looks like for a another argument, in case you didn't fill it out correctly (e.g. shape_str = "penelope").
```{r}
compute_area(3, "penelope")
```






假設你的函數名稱也是compute_area，且參數順序是邊長（半徑）和形狀，那以下的結果應該要是一樣的。

```{r func.call.circle, echo=TRUE}
circle <- function(r_in, shape_str){
  circ_ret <- compute_area(r_in, shape_str = "circle")
  return(c(circle_area=circ_ret[1], circle_circum=circ_ret[2]))
}
```

So for a radius of 6.5 in a circle, we get:
```{r}
circle(6.5, "circle")
```

e.g. circ_ret <- compute_area(6.5, "circle")


```r
circ_ret <- compute_area(6.5, "circle")
##   circle_area circle_circum 
##      132.7323       40.8407
```

the function for squares:

```{r func.call.square, echo=TRUE}
square <- function(r_in, shape_str){
  sqr_ret <- compute_area(r_in, shape_str = "square")
  return(c(square_area=sqr_ret[1], square_circum=sqr_ret[2]))
}
```


so for a square with side length = 5.2, we get:
```{r}
square(5.2, "square")
```


```r
sqr_ret <- compute_area(5.2, "square")
##   square_area square_circum 
##         27.04         20.80
```

#### 評分標準：
* 定義compute_area函數(10%)
* compute_area函數可接受兩個參數(10%)
* 當形狀參數為"circle"時，可正確計算其面積(10%)和邊長(10%)。
* 當形狀參數為"square"時，可正確計算其面積(10%)和邊長(10%)。
* 回傳的vector有恰當名稱，標明其值為面積或邊長(10%)。



## B. Plot the future  (30%)

### 繪圖函數
R內建很豐富的繪圖指令，例如繪製散佈圖scatterplot、折線圖lineplot的plot
和直方圖histogram的hist。請用說明文件幫助你找到正確的方式畫出散佈圖、折線圖和直方圖。

繪圖用的資料可以用以下code chunk直接產生。請注意，由於是資料是隨機產生的，
每次執行的資料都會是不同的。

您需要用以下的plot_data完成3張圖：

1. x 和 y 的散佈圖(10%)
2. x 和 z 的折線圖(10%)
3. y 的直方圖(10%)

您只需要繪製出圖本身即可。但當然歡迎幫它加上標題、顏色、軸標題等等。

```{r data.prep, echo=TRUE}
plot_data = data.frame(
    x <- 1:100,
    y <- 50 + 10 * rnorm(length(x), 0, 1),
    z <- x * 0.8 + rnorm(length(x), 0, 4)
)
```

```{r scatter.code, echo=TRUE}
with(plot_data, plot(x, y))

#library(ggplot2)
#ggplot(data = plot_data) +
#  geom_point(mapping = aes(x = x, y = y), color = "blue") +
#  ggtitle("x ~ y")
```

```{r line.code, echo=TRUE}
with(plot_data, plot(x, z, type = "l"))

#ggplot (data = plot_data) +
#  geom_line(mapping = aes(x = x, y = z), color = "red")

```

```{r hist.code, echo=TRUE}
hist(y)

```

## 進階選答題

### Problem A (10%)

這一題我們會用到R的內建資料集，CO2，你可以用`help(CO2)`查詢該資料內的變項和說明。
我們現在想要整理這筆資料，計算Treatment和Type兩變項下各四個情境的uptake平均數 (mean)。
您可以先用head, plot, unique,
table等函數看看資料內容，然後用課堂上講到的for迴圈、mean函數來整理資料。
或者，您也可以不用for迴圈，用R的內建指令或其他套件來完成這個分析。

您分析完成的結果，可能會類似這樣：

```
   Treatment        Type   uptake
1 nonchilled      Quebec  <value>
2    chilled      Quebec  <value>
3 nonchilled Mississippi  <value>
4    chilled Mississippi  <value>
```

#### 評分標準：  

* 將資料整理成如上述形式。

```{r data.agg, echo=TRUE}
#head(CO2)
#dim(CO2)
#summary(CO2)
#plot(CO2)
help("CO2")
#names(CO2)

#unique(CO2$Treatment)
#unique(CO2$Type)

library(dplyr)

sol <- CO2 %>%
  group_by(Treatment, Type) %>%
  summarise(mean(uptake)) %>%
  arrange(Type)

sol

```




### Problem B (10%)

以下有一個資料產生函數`rn100()`，每呼叫一次它都會產生出100個數值。
請重複呼叫他20次，並把這20次的結果分別以不同顏色，繪製成折線圖，並呈現在同一張圖上。

繪出的圖應該會有20條折線，x軸就是1到100，y軸就是函數產生的數值，圖上應該有20條顏色不同的線。
您畫出的圖形應該會很像這個樣子，但由於rn100是隨機函數，所以結果不會完全相同，您也不需使用相同的顏色。


#### 評分標準：  

* 將20條線畫在同一張圖中(5%)。
* 每條線有不同的顏色(5%)。

---
```{r rn100, echo=TRUE}
rn100 <- function() cumsum(rnorm(100, 0, 1))
```



```{r}
x  <- seq(1:100)
y1 <- rn100()
y2 <- rn100()
y3 <- rn100()
y4 <- rn100()
y5 <- rn100()
y6 <- rn100()
y7 <- rn100()
y8 <- rn100()
y9 <- rn100()
y10 <- rn100()
y11 <- rn100()
y12 <- rn100()
y13 <- rn100()
y14 <- rn100()
y15 <- rn100()
y16 <- rn100()
y17 <- rn100()
y18 <- rn100()
y19 <- rn100()
y20 <- rn100()


df <- tibble(x,y1,y2,y3,y4,y5,y6,y7,y8,y9,y10,y11,y12,y13,y14,y15,y16,y17,y18,y19,y20)
df
#dim(df)
```

```{r}

library(ggplot2)

ggplot(df, aes(x)) +                    # basic graphical object
  geom_line(aes(y=y1), colour = "red") +  # first layer
  geom_line(aes(y=y2), colour = "blue") +
  geom_line(aes(y=y3), colour = "green") +
  geom_line(aes(y=y4), colour = "aquamarine") +
  geom_line(aes(y=y5), colour = "bisque") +
  geom_line(aes(y=y6), colour = "blueviolet") +
  geom_line(aes(y=y7), colour = "brown") +
  geom_line(aes(y=y8), colour = "cadetblue") +
  geom_line(aes(y=y9), colour = "chartreuse") +
  geom_line(aes(y=y10), colour = "chocolate") +
  geom_line(aes(y=y11), colour = "coral") +
  geom_line(aes(y=y12), colour = "darkgoldenrod") +
  geom_line(aes(y=y13), colour = "darkgreen") +
  geom_line(aes(y=y14), colour = "darkorchid") +
  geom_line(aes(y=y15), colour = "deeppink") +
  geom_line(aes(y=y16), colour = "gold") +
  geom_line(aes(y=y17), colour = "dodgerblue4") +
  geom_line(aes(y=y18), colour = "darkorange") +
  geom_line(aes(y=y19), colour = "salmon") +
  geom_line(aes(y=y20), colour = "darkcyan") +
  labs(title = "Multiple Random Plot", x = "Index", y = "rn100")
  
  
  
```


---

# Trying to improve the last bit of code:

```{r rn100, echo=TRUE}
random100 <- function(x) {
  cumsum(rnorm(100, 0, 1))
}
```

WHY DOES THIS WORK BUT USING RANDOM100 DOESN'T??
```{r}
# this has an x but is not the same as given function
#df2 <- sapply(1:20, function(x) cumsum(rnorm(100, 0, 1)))
#df2 <- as.tibble(df2)
#df2
# this doesn't work
#sapply(1:20, random100)

#unused argument (x)  -- but doesn't sapply want an x?
#sapply(1:20, random100(x))

#it says 'random100()' is not a function but it is! I just defined it?
df2 <- sapply(1:20, random100)
df2 <- as.tibble(df2)
df2


```



```{r}
head(airquality)
library(ggplot2)

summary(airquality)

airquality %>%
  ggplot(aes(x= Ozone, y = Temp)) +
  geom_point() +
  geom_line(aes(y = Wind), colour = "blue") +
  geom_line(aes(y = Solar.R), colour = "red")
```

```{r}
m1 = lm(Ozone~Solar.R + Wind + Temp, airquality)
m1
```



```{r}
m2 = with(airquality, glm(Ozone~Solar.R + Wind + Temp, family="poisson"))

m2
```


```{r}
df <- df2 %>%
  add_column(new = 1:100) %>%
  gather(V1:V20, key = "group_v", value = "v")
df
```

Drawing the picture, grouping by y-value
```{r}
ggplot(df, aes(x = new)) +
  geom_line(aes(y=v, color=group_v), show.legend = F) +
  labs(title = "Multiple Random Plot", x = "Index", y = "rn100")
```


